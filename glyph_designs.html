<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Glyph Design | Multivariate Timeseries</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_observablehq/theme-near-midnight.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_observablehq/theme-near-midnight.css">
<link rel="modulepreload" href="./_observablehq/client.js">
<link rel="modulepreload" href="./_observablehq/runtime.js">
<link rel="modulepreload" href="./_observablehq/stdlib.js">
<script type="module">

import {define} from "./_observablehq/client.js";
import {registerFile, FileAttachment} from "./_observablehq/stdlib.js";
import {registerTable} from "./_observablehq/stdlib/duckdb.js";

registerFile("./data/formatted_cbe_scenarios.csv", {"name":"./data/formatted_cbe_scenarios.csv","mimeType":"text/csv","path":"./_file/data/formatted_cbe_scenarios.96cb640f.csv","lastModified":1715938803431});
registerTable("scenariosdb", FileAttachment("./data/formatted_cbe_scenarios.csv"));

define({id: "ff127602", outputs: ["dummyData"], body: () => {
const dummyData = [
  {
    budget: "capped15000k",
    lsoa: "E01017987",
    year: 2024,
    technology: "heat pumps",
    total_material_cost: 37743.8,
    total_labour_cost: 13600,
    total_cost: 51343.8,
  },
  {
    budget: "capped15000k",
    lsoa: "E01017987",
    year: 2026,
    technology: "insulation",
    total_material_cost: 49763.78000000001,
    total_labour_cost: 41359.12,
    total_cost: 91122.9,
  },
];
return {dummyData};
}});

define({id: "38ae203e", inputs: ["dummyData"], outputs: ["drawTimeseries"], body: (dummyData) => {
// local canvas variables
function drawTimeseries(ctx, x, y, data = dummyData, padding = 2) {
  const cellSize = ctx.canvas.width;
  const centerX = x;
  const centerY = y;

  // maximum radius based on glyph cell size
  const radius = (cellSize - 2 * padding) / 2;
  const innerRadius = radius / 5;

  // sectors
  const numSectors = 3; // budget.length()
  const sectorAngle = (2 * Math.PI) / numSectors;
  // segment inside sectors
  const numSegments = 4; // technology.length()
  const segmentRadius = radius / 5; // 1/5 of the radius
  const segmentAngle = sectorAngle / numSegments;
  // part inside segments
  const partNumber = 22;
  const partRadius = radius / partNumber;

  for (let i = 0; i < numSectors; i++) {
    let sectorStartAngle = i * sectorAngle - Math.PI / 2;
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    let startAngle = i * sectorAngle - Math.PI / 2;
    let endAngle = startAngle + sectorAngle;
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
    ctx.closePath();
    ctx.fillStyle = `hsl(${(i / numSectors) * 360}, 80%, 60%)`;
    ctx.fill();

    // draw each segment within the sector
    for (let j = 0; j < numSegments; j++) {
      ctx.beginPath();
      ctx.lineWidth = 0.15;
      ctx.strokeStyle = "black";
      let startAngle = sectorStartAngle + j * segmentAngle;
      let endAngle = startAngle + segmentAngle;
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.stroke();
      ctx.closePath();

      for (let k = 0; k < partNumber; k++) {
        ctx.beginPath();
        ctx.lineWidth = 0.2;
        ctx.strokeStyle = "black";
        ctx.arc(centerX, centerY, partRadius * (k + 1), startAngle, endAngle);
        ctx.lineTo(centerX, centerY);
        ctx.stroke();
        ctx.closePath();
      }
    }
  }

  // inner circle
  ctx.beginPath();
  ctx.fillStyle = "white";
  ctx.lineWidth = 1;
  ctx.strokeStyle = "black";
  ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI);
  ctx.fill();
  ctx.stroke();
  ctx.closePath();
}
return {drawTimeseries};
}});

define({id: "3654d9da", inputs: ["dummyData"], outputs: ["drawTimeseries2"], body: (dummyData) => {
function drawTimeseries2(ctx, x, y, data = dummyData, padding = 2) {
  const cellSize = ctx.canvas.width;
  const centerX = x;
  const centerY = y;

  // maximum radius based on glyph cell size
  const radius = (cellSize - 2 * padding) / 2;
  const innerRadius = radius / 5;

  const gapAngle = 0; // (3 * Math.PI) / 180; // 3 degree gap

  // sectors
  const numSectors = 3; // budget.length()
  //   const sectorAngle = (2 * Math.PI) / numSectors;
  const sectorAngle = (2 * Math.PI) / numSectors - gapAngle; // Subtract gapAngle from sectorAngle
  // segment inside sectors
  const numSegments = 4; // technology.length()
  const segmentAngle = sectorAngle / numSegments;
  // part inside segments
  const partNumber = 22;
  const partRadius = (radius - innerRadius) / partNumber;

  for (let i = 0; i < numSectors; i++) {
    // let sectorStartAngle = i * sectorAngle - Math.PI / 2;
    let sectorStartAngle = i * (sectorAngle + gapAngle) - Math.PI / 2;

    // draw the sector
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    // let startAngle = i * sectorAngle - Math.PI / 2;
    let startAngle = i * (sectorAngle + gapAngle) - Math.PI / 2;
    let endAngle = startAngle + sectorAngle;
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
    ctx.closePath();
    ctx.fillStyle = `hsl(${(i / numSectors) * 360}, 80%, 60%)`;
    ctx.fill();

    // draw each segment within the sector
    for (let j = 0; j < numSegments; j++) {
      let startAngle = sectorStartAngle + j * segmentAngle;
      let endAngle = startAngle + segmentAngle;

      // draw each part within the segment
      for (let k = 0; k < partNumber; k++) {
        ctx.beginPath();
        ctx.lineWidth = 0.2;
        // ctx.strokeStyle = "black";
        ctx.arc(
          centerX,
          centerY,
          innerRadius + partRadius * (k + 1),
          startAngle,
          endAngle
        );
        ctx.lineTo(centerX, centerY);
        ctx.stroke();
        ctx.closePath();
      }
    }
  }

  // inner circle
  ctx.beginPath();
  ctx.fillStyle = "white";
  ctx.lineWidth = 1;
  ctx.strokeStyle = "black";
  ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI);
  ctx.fill();
  ctx.stroke();
  ctx.closePath();
}
return {drawTimeseries2};
}});

define({id: "035f8202", inputs: ["drawTimeseries2","dummyData"], body: (drawTimeseries2,dummyData) => {
{
  const canvas = document.querySelector("#glyph3");
  const ctx = canvas.getContext("2d");
  // canvas.width = width;
  ctx.fillStyle = "lightgrey";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;

  drawTimeseries2(ctx, centerX, centerY, dummyData);
}
}});

define({id: "01ba4719", body: () => {

}});

define({id: "764031e7", body: () => {
// draw function here

// draw!
{
  const canvas = document.querySelector("#glyph2");
  const ctx = canvas.getContext("2d");
  // canvas.width = width;
  ctx.fillStyle = "lightgrey";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const radius = canvas.width / 2;
  const numSectors = 3;
  const sectorAngle = (Math.PI * 2) / numSectors;

  ctx.translate(canvas.width / 2, canvas.height / 2);

  for (let i = 0; i < numSectors; i++) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(radius, 0);
    ctx.arc(0, 0, radius, 0, sectorAngle);
    ctx.closePath();
    ctx.fillStyle = `hsl(${(i / numSectors) * 360}, 50%, 50%)`;
    ctx.fill();
    ctx.rotate(sectorAngle);
  }
}
}});

define({id: "1a121b7a", inputs: ["BarChart"], outputs: ["myCanvas","ctx","myBarchart"], body: (BarChart) => {
var myCanvas = document.getElementById("myCanvas");
myCanvas.width = 500;
myCanvas.height = 500;

var ctx = myCanvas.getContext("2d");

var myBarchart = new BarChart({
  canvas: myCanvas,
  padding: 40,
  gridScale: 5,
  gridColor: "black",
  data: {
    "Classical Music": 16,
    "Alternative Rock": 12,
    Pop: 18,
    Jazz: 32,
  },
  colors: ["#a55ca5", "#67b6c7", "#bccd7a", "#eb9743"],
});
myBarchart.draw();
return {myCanvas,ctx,myBarchart};
}});

define({id: "1e33d6b9", inputs: ["weights","categories","selected_parameters","canvasPattern"], outputs: ["drawBarChart"], body: (weights,categories,selected_parameters,canvasPattern) => {
function drawBarChart(
  ctx,
  x,
  y,
  cellSize,
  data, // Aggregated data
  colours,
  background,
  padding = 0
) {
  const gap = 2; // Gap between categories
  let lastCategory = null;

  // calculate maximum absolute weight for positioning
  const maxAbsoluteWeight = Math.max(...Object.values(weights).map(Math.abs));

  // calculate total width of bars based on weights
  const totalBarWidth = Object.values(weights).reduce(
    (sum, weight) => sum + Math.abs(weight),
    0
  );

  const availableWidth =
    cellSize -
    2 * maxAbsoluteWeight -
    gap * (categories.length - 1) - // + 15; // the 15 px offset, from observable (?)
    2 * padding;

  // Calculate starting position for the first bar from the bottom of the cell
  let currentX = x - availableWidth / 2 + padding - 5; // not sure why observable have certain offset to the canvas
  let barY = y + cellSize / 2 - padding; // Start from the bottom of the cell

  // Iterate over each parameter and draw its bar
  selected_parameters.forEach((parameter, i) => {
    const value = data[parameter]; // Access value from aggregated data
    const color = colours[i];
    const weight = weights[parameter];
    const category = categories.find((c) => c.parameter === parameter).category;

    // Calculate bar width based on weight and total bar width
    let barWidth = (Math.abs(weight) * availableWidth) / totalBarWidth;

    const minBarWidth = 1;
    barWidth = Math.max(barWidth, minBarWidth);

    // Calculate bar height based on value and full cell height
    const barHeight = (value / 100) * (cellSize - 2 * padding); // Use full cell height

    // Add a gap if the category has changed
    if (lastCategory && lastCategory !== category) {
      currentX += gap;
    }
    lastCategory = category;

    // Draw the bar
    ctx.fillStyle = color;
    ctx.fillRect(currentX, barY, barWidth, -barHeight); // Draw solid bar with negative height

    // Draw a thick  border for negative weights
    if (weight < 0) {
      // ctx.save();
      const pattern = ctx.createPattern(canvasPattern, "repeat");
      ctx.fillStyle = pattern;
      ctx.fillRect(currentX, barY, barWidth, -barHeight);
      // ctx.fill();
      // ctx.restore();

      // stroke
      ctx.lineWidth = 1;
      ctx.strokeStyle = "white"; // white border on negative weight
      ctx.strokeRect(currentX - padding, barY, barWidth, -barHeight);
    }

    // Update starting position for the next bar
    currentX += barWidth;
  });
}
return {drawBarChart};
}});

</script>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link"><a href="./">Multivariate Timeseries</a></li>
  </ol>
  <ol>
    <section>
      <summary>Time-series Gridded-glyphmaps</summary>
      <ol>
    <li class="observablehq-link"><a href="./data_exploration">Data Exploration</a></li>
    <li class="observablehq-link"><a href="./dashboard">Dashboard</a></li>
      </ol>
    </section>
  </ol>
</nav>
<script>{Object.assign(document.createElement("a"),{href:""}).password&&location.replace(location.href);const e=document.querySelector("#observablehq-sidebar"),t=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?t.checked=r==="true":t.indeterminate=!0;for(const o of document.querySelectorAll("#observablehq-sidebar summary")){const s=o.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${o.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<aside id="observablehq-toc" data-selector="h1:not(:first-of-type), h2:first-child, :not(h1) + h2">
<nav>
<div>Contents</div>
<ol>
<li class="observablehq-secondary-link"><a href="#radial-barchart">Radial Barchart</a></li>
<li class="observablehq-secondary-link"><a href="#small-multiples">Small multiples</a></li>
<li class="observablehq-secondary-link"><a href="#nightingale-chart">Nightingale chart</a></li>
<li class="observablehq-secondary-link"><a href="#experiments">Experiments</a></li>
</ol>
</nav>
</aside>
<div id="observablehq-center">
<main id="observablehq-main" class="observablehq">
<h1 id="glyph-designs" tabindex="-1"><a class="observablehq-header-anchor" href="#glyph-designs">Glyph Designs</a></h1>
<p>test canvas</p>
<div id="cell-ff127602" class="observablehq observablehq--block"></div>
<h2 id="radial-barchart" tabindex="-1"><a class="observablehq-header-anchor" href="#radial-barchart">Radial Barchart</a></h2>
<figure style="max-width: 100%;">
  <canvas id="glyph3" width="300" height="300"></canvas>
</figure>
<div id="cell-38ae203e" class="observablehq observablehq--block"></div>
<div id="cell-3654d9da" class="observablehq observablehq--block"></div>
<div id="cell-035f8202" class="observablehq observablehq--block"></div>
<hr>
<h2 id="small-multiples" tabindex="-1"><a class="observablehq-header-anchor" href="#small-multiples">Small multiples</a></h2>
<figure style="max-width: 100%;">
  <canvas id="glyph1" width="300" height="300"></canvas>
</figure>
<div id="cell-01ba4719" class="observablehq observablehq--block"></div>
<h2 id="nightingale-chart" tabindex="-1"><a class="observablehq-header-anchor" href="#nightingale-chart">Nightingale chart</a></h2>
<figure style="max-width: 100%;">
  <canvas id="glyph2" width="300" height="300"></canvas>
</figure>
<div id="cell-764031e7" class="observablehq observablehq--block"></div>
<h2 id="experiments" tabindex="-1"><a class="observablehq-header-anchor" href="#experiments">Experiments</a></h2>
<figure style="max-width: 100%;">
  <canvas id="myCanvas" width="300" height="300"></canvas>
</figure>
<div id="cell-1a121b7a" class="observablehq observablehq--block"></div>
<figure style="max-width: 100%;">
  <canvas id="myCanvas2" width="300" height="300"></canvas>
</figure>
<div id="cell-1e33d6b9" class="observablehq observablehq--block"></div>
<!--

<figure style="max-width: 100%;">
  <canvas id="flower" width="400" height="400"></canvas>
</figure>

```js
// flower petals
function drawCascadingPetal(ctx, length, angle, color1, color2) {
  ctx.save();
  ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);
  ctx.rotate(angle);

  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.bezierCurveTo(
    length / 4 + Math.random() * 5,
    -length / 2 - Math.random() * 10,
    length / 2,
    -length / 3 + Math.random() * 5,
    length,
    0
  );
  ctx.bezierCurveTo(
    length / 2,
    length / 3 + Math.random() * 5,
    length / 4 + Math.random() * 5,
    length / 2 + Math.random() * 10,
    0,
    0
  );
  // add stroke
  ctx.strokeStyle = "rgba(206, 0, 245, 0.6)"; //"purple";
  ctx.stroke();
  ctx.closePath();

  // Gradient for depth
  const gradient = ctx.createLinearGradient(0, 0, length + 10, 0);
  gradient.addColorStop(0, color1);
  gradient.addColorStop(1, color2);
  ctx.fillStyle = gradient;

  ctx.fill();
  ctx.restore();
}

// draw!

{
  const canvas = document.querySelector("#flower");
  const ctx = canvas.getContext("2d");
  // canvas.width = width;
  ctx.fillStyle = "lightgrey";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const numPetals = 8;

  const petalLengths = Array(numPetals).fill(180);

  // Draw cascading petals with gradients
  for (let i = 0; i < numPetals; i++) {
    const angle = (i * Math.PI * 2) / numPetals;
    const color1 = "rgba(254, 95, 177, 0.75)"; //"lightpink";
    const color2 = "rgba(245, 0, 127, 0.8)"; //"hotpink";
    drawCascadingPetal(ctx, petalLengths[i], angle, color1, color2);
  }

  // Draw the center
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(canvas.width / 2, canvas.height / 2, 8, 0, Math.PI * 2);
  ctx.fill();
}
``` -->
</main>
</div>
