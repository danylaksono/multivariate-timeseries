/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@floating-ui/core@1.6.1/dist/floating-ui.core.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{evaluate as e,getPaddingObject as t,rectToClientRect as n,getAlignmentAxis as i,getAxisLength as o,min as r,clamp as a,getAlignment as l,placements as s,getAlignmentSides as c,getSide as f,getOppositePlacement as m,getExpandedPlacements as u,getOppositeAxisPlacements as d,getSideAxis as g,getOppositeAxis as p,max as h,getOppositeAlignmentPlacement as y,sides as w}from"../utils@0.2.2/_esm.js";export{rectToClientRect}from"../utils@0.2.2/_esm.js";function x(e,t,n){let{reference:r,floating:a}=e;const s=g(t),c=i(t),m=o(c),u=f(t),d="y"===s,p=r.x+r.width/2-a.width/2,h=r.y+r.height/2-a.height/2,y=r[m]/2-a[m]/2;let w;switch(u){case"top":w={x:p,y:r.y-a.height};break;case"bottom":w={x:p,y:r.y+r.height};break;case"right":w={x:r.x+r.width,y:h};break;case"left":w={x:r.x-a.width,y:h};break;default:w={x:r.x,y:r.y}}switch(l(t)){case"start":w[c]-=y*(n&&d?-1:1);break;case"end":w[c]+=y*(n&&d?-1:1)}return w}const v=async(e,t,n)=>{const{placement:i="bottom",strategy:o="absolute",middleware:r=[],platform:a}=n,l=r.filter(Boolean),s=await(null==a.isRTL?void 0:a.isRTL(t));let c=await a.getElementRects({reference:e,floating:t,strategy:o}),{x:f,y:m}=x(c,i,s),u=i,d={},g=0;for(let n=0;n<l.length;n++){const{name:r,fn:p}=l[n],{x:h,y:y,data:w,reset:v}=await p({x:f,y:m,initialPlacement:i,placement:u,strategy:o,middlewareData:d,rects:c,platform:a,elements:{reference:e,floating:t}});f=null!=h?h:f,m=null!=y?y:m,d={...d,[r]:{...d[r],...w}},v&&g<=50&&(g++,"object"==typeof v&&(v.placement&&(u=v.placement),v.rects&&(c=!0===v.rects?await a.getElementRects({reference:e,floating:t,strategy:o}):v.rects),({x:f,y:m}=x(c,u,s))),n=-1)}return{x:f,y:m,placement:u,strategy:o,middlewareData:d}};async function b(i,o){var r;void 0===o&&(o={});const{x:a,y:l,platform:s,rects:c,elements:f,strategy:m}=i,{boundary:u="clippingAncestors",rootBoundary:d="viewport",elementContext:g="floating",altBoundary:p=!1,padding:h=0}=e(o,i),y=t(h),w=f[p?"floating"===g?"reference":"floating":g],x=n(await s.getClippingRect({element:null==(r=await(null==s.isElement?void 0:s.isElement(w)))||r?w:w.contextElement||await(null==s.getDocumentElement?void 0:s.getDocumentElement(f.floating)),boundary:u,rootBoundary:d,strategy:m})),v="floating"===g?{x:a,y:l,width:c.floating.width,height:c.floating.height}:c.reference,b=await(null==s.getOffsetParent?void 0:s.getOffsetParent(f.floating)),A=await(null==s.isElement?void 0:s.isElement(b))&&await(null==s.getScale?void 0:s.getScale(b))||{x:1,y:1},R=n(s.convertOffsetParentRelativeRectToViewportRelativeRect?await s.convertOffsetParentRelativeRectToViewportRelativeRect({elements:f,rect:v,offsetParent:b,strategy:m}):v);return{top:(x.top-R.top+y.top)/A.y,bottom:(R.bottom-x.bottom+y.bottom)/A.y,left:(x.left-R.left+y.left)/A.x,right:(R.right-x.right+y.right)/A.x}}const A=n=>({name:"arrow",options:n,async fn(s){const{x:c,y:f,placement:m,rects:u,platform:d,elements:g,middlewareData:p}=s,{element:h,padding:y=0}=e(n,s)||{};if(null==h)return{};const w=t(y),x={x:c,y:f},v=i(m),b=o(v),A=await d.getDimensions(h),R="y"===v,P=R?"top":"left",D=R?"bottom":"right",T=R?"clientHeight":"clientWidth",E=u.reference[b]+u.reference[v]-x[v]-u.floating[b],O=x[v]-u.reference[v],L=await(null==d.getOffsetParent?void 0:d.getOffsetParent(h));let k=L?L[T]:0;k&&await(null==d.isElement?void 0:d.isElement(L))||(k=g.floating[T]||u.floating[b]);const C=E/2-O/2,B=k/2-A[b]/2-1,H=r(w[P],B),S=r(w[D],B),F=H,V=k-A[b]-S,W=k/2-A[b]/2+C,j=a(F,W,V),z=!p.arrow&&null!=l(m)&&W!==j&&u.reference[b]/2-(W<F?H:S)-A[b]/2<0,q=z?W<F?W-F:W-V:0;return{[v]:x[v]+q,data:{[v]:j,centerOffset:W-j-q,...z&&{alignmentOffset:q}},reset:z}}});const R=function(t){return void 0===t&&(t={}),{name:"autoPlacement",options:t,async fn(n){var i,o,r;const{rects:a,middlewareData:m,placement:u,platform:d,elements:g}=n,{crossAxis:p=!1,alignment:h,allowedPlacements:w=s,autoAlignment:x=!0,...v}=e(t,n),A=void 0!==h||w===s?function(e,t,n){return(e?[...n.filter((t=>l(t)===e)),...n.filter((t=>l(t)!==e))]:n.filter((e=>f(e)===e))).filter((n=>!e||l(n)===e||!!t&&y(n)!==n))}(h||null,x,w):w,R=await b(n,v),P=(null==(i=m.autoPlacement)?void 0:i.index)||0,D=A[P];if(null==D)return{};const T=c(D,a,await(null==d.isRTL?void 0:d.isRTL(g.floating)));if(u!==D)return{reset:{placement:A[0]}};const E=[R[f(D)],R[T[0]],R[T[1]]],O=[...(null==(o=m.autoPlacement)?void 0:o.overflows)||[],{placement:D,overflows:E}],L=A[P+1];if(L)return{data:{index:P+1,overflows:O},reset:{placement:L}};const k=O.map((e=>{const t=l(e.placement);return[e.placement,t&&p?e.overflows.slice(0,2).reduce(((e,t)=>e+t),0):e.overflows[0],e.overflows]})).sort(((e,t)=>e[1]-t[1])),C=(null==(r=k.filter((e=>e[2].slice(0,l(e[0])?2:3).every((e=>e<=0))))[0])?void 0:r[0])||k[0][0];return C!==u?{data:{index:P+1,overflows:O},reset:{placement:C}}:{}}}},P=function(t){return void 0===t&&(t={}),{name:"flip",options:t,async fn(n){var i,o;const{placement:r,middlewareData:a,rects:l,initialPlacement:s,platform:g,elements:p}=n,{mainAxis:h=!0,crossAxis:y=!0,fallbackPlacements:w,fallbackStrategy:x="bestFit",fallbackAxisSideDirection:v="none",flipAlignment:A=!0,...R}=e(t,n);if(null!=(i=a.arrow)&&i.alignmentOffset)return{};const P=f(r),D=f(s)===s,T=await(null==g.isRTL?void 0:g.isRTL(p.floating)),E=w||(D||!A?[m(s)]:u(s));w||"none"===v||E.push(...d(s,A,v,T));const O=[s,...E],L=await b(n,R),k=[];let C=(null==(o=a.flip)?void 0:o.overflows)||[];if(h&&k.push(L[P]),y){const e=c(r,l,T);k.push(L[e[0]],L[e[1]])}if(C=[...C,{placement:r,overflows:k}],!k.every((e=>e<=0))){var B,H;const e=((null==(B=a.flip)?void 0:B.index)||0)+1,t=O[e];if(t)return{data:{index:e,overflows:C},reset:{placement:t}};let n=null==(H=C.filter((e=>e.overflows[0]<=0)).sort(((e,t)=>e.overflows[1]-t.overflows[1]))[0])?void 0:H.placement;if(!n)switch(x){case"bestFit":{var S;const e=null==(S=C.map((e=>[e.placement,e.overflows.filter((e=>e>0)).reduce(((e,t)=>e+t),0)])).sort(((e,t)=>e[1]-t[1]))[0])?void 0:S[0];e&&(n=e);break}case"initialPlacement":n=s}if(r!==n)return{reset:{placement:n}}}return{}}}};function D(e,t){return{top:e.top-t.height,right:e.right-t.width,bottom:e.bottom-t.height,left:e.left-t.width}}function T(e){return w.some((t=>e[t]>=0))}const E=function(t){return void 0===t&&(t={}),{name:"hide",options:t,async fn(n){const{rects:i}=n,{strategy:o="referenceHidden",...r}=e(t,n);switch(o){case"referenceHidden":{const e=D(await b(n,{...r,elementContext:"reference"}),i.reference);return{data:{referenceHiddenOffsets:e,referenceHidden:T(e)}}}case"escaped":{const e=D(await b(n,{...r,altBoundary:!0}),i.floating);return{data:{escapedOffsets:e,escaped:T(e)}}}default:return{}}}}};function O(e){const t=r(...e.map((e=>e.left))),n=r(...e.map((e=>e.top)));return{x:t,y:n,width:h(...e.map((e=>e.right)))-t,height:h(...e.map((e=>e.bottom)))-n}}const L=function(i){return void 0===i&&(i={}),{name:"inline",options:i,async fn(o){const{placement:a,elements:l,rects:s,platform:c,strategy:m}=o,{padding:u=2,x:d,y:p}=e(i,o),y=Array.from(await(null==c.getClientRects?void 0:c.getClientRects(l.reference))||[]),w=function(e){const t=e.slice().sort(((e,t)=>e.y-t.y)),i=[];let o=null;for(let e=0;e<t.length;e++){const n=t[e];!o||n.y-o.y>o.height/2?i.push([n]):i[i.length-1].push(n),o=n}return i.map((e=>n(O(e))))}(y),x=n(O(y)),v=t(u);const b=await c.getElementRects({reference:{getBoundingClientRect:function(){if(2===w.length&&w[0].left>w[1].right&&null!=d&&null!=p)return w.find((e=>d>e.left-v.left&&d<e.right+v.right&&p>e.top-v.top&&p<e.bottom+v.bottom))||x;if(w.length>=2){if("y"===g(a)){const e=w[0],t=w[w.length-1],n="top"===f(a),i=e.top,o=t.bottom,r=n?e.left:t.left,l=n?e.right:t.right;return{top:i,bottom:o,left:r,right:l,width:l-r,height:o-i,x:r,y:i}}const e="left"===f(a),t=h(...w.map((e=>e.right))),n=r(...w.map((e=>e.left))),i=w.filter((i=>e?i.left===n:i.right===t)),o=i[0].top,l=i[i.length-1].bottom;return{top:o,bottom:l,left:n,right:t,width:t-n,height:l-o,x:n,y:o}}return x}},floating:l.floating,strategy:m});return s.reference.x!==b.reference.x||s.reference.y!==b.reference.y||s.reference.width!==b.reference.width||s.reference.height!==b.reference.height?{reset:{rects:b}}:{}}}};const k=function(t){return void 0===t&&(t=0),{name:"offset",options:t,async fn(n){var i,o;const{x:r,y:a,placement:s,middlewareData:c}=n,m=await async function(t,n){const{placement:i,platform:o,elements:r}=t,a=await(null==o.isRTL?void 0:o.isRTL(r.floating)),s=f(i),c=l(i),m="y"===g(i),u=["left","top"].includes(s)?-1:1,d=a&&m?-1:1,p=e(n,t);let{mainAxis:h,crossAxis:y,alignmentAxis:w}="number"==typeof p?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...p};return c&&"number"==typeof w&&(y="end"===c?-1*w:w),m?{x:y*d,y:h*u}:{x:h*u,y:y*d}}(n,t);return s===(null==(i=c.offset)?void 0:i.placement)&&null!=(o=c.arrow)&&o.alignmentOffset?{}:{x:r+m.x,y:a+m.y,data:{...m,placement:s}}}}},C=function(t){return void 0===t&&(t={}),{name:"shift",options:t,async fn(n){const{x:i,y:o,placement:r}=n,{mainAxis:l=!0,crossAxis:s=!1,limiter:c={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...m}=e(t,n),u={x:i,y:o},d=await b(n,m),h=g(f(r)),y=p(h);let w=u[y],x=u[h];if(l){const e="y"===y?"bottom":"right",t=w+d["y"===y?"top":"left"],n=w-d[e];w=a(t,w,n)}if(s){const e="y"===h?"bottom":"right",t=x+d["y"===h?"top":"left"],n=x-d[e];x=a(t,x,n)}const v=c.fn({...n,[y]:w,[h]:x});return{...v,data:{x:v.x-i,y:v.y-o}}}}},B=function(t){return void 0===t&&(t={}),{options:t,fn(n){const{x:i,y:o,placement:r,rects:a,middlewareData:l}=n,{offset:s=0,mainAxis:c=!0,crossAxis:m=!0}=e(t,n),u={x:i,y:o},d=g(r),h=p(d);let y=u[h],w=u[d];const x=e(s,n),v="number"==typeof x?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(c){const e="y"===h?"height":"width",t=a.reference[h]-a.floating[e]+v.mainAxis,n=a.reference[h]+a.reference[e]-v.mainAxis;y<t?y=t:y>n&&(y=n)}if(m){var b,A;const e="y"===h?"width":"height",t=["top","left"].includes(f(r)),n=a.reference[d]-a.floating[e]+(t&&(null==(b=l.offset)?void 0:b[d])||0)+(t?0:v.crossAxis),i=a.reference[d]+a.reference[e]+(t?0:(null==(A=l.offset)?void 0:A[d])||0)-(t?v.crossAxis:0);w<n?w=n:w>i&&(w=i)}return{[h]:y,[d]:w}}}},H=function(t){return void 0===t&&(t={}),{name:"size",options:t,async fn(n){const{placement:i,rects:o,platform:a,elements:s}=n,{apply:c=(()=>{}),...m}=e(t,n),u=await b(n,m),d=f(i),p=l(i),y="y"===g(i),{width:w,height:x}=o.floating;let v,A;"top"===d||"bottom"===d?(v=d,A=p===(await(null==a.isRTL?void 0:a.isRTL(s.floating))?"start":"end")?"left":"right"):(A=d,v="end"===p?"top":"bottom");const R=x-u[v],P=w-u[A],D=!n.middlewareData.shift;let T=R,E=P;if(y){const e=w-u.left-u.right;E=p||D?r(P,e):e}else{const e=x-u.top-u.bottom;T=p||D?r(R,e):e}if(D&&!p){const e=h(u.left,0),t=h(u.right,0),n=h(u.top,0),i=h(u.bottom,0);y?E=w-2*(0!==e||0!==t?e+t:h(u.left,u.right)):T=x-2*(0!==n||0!==i?n+i:h(u.top,u.bottom))}await c({...n,availableWidth:E,availableHeight:T});const O=await a.getDimensions(s.floating);return w!==O.width||x!==O.height?{reset:{rects:!0}}:{}}}};export{A as arrow,R as autoPlacement,v as computePosition,b as detectOverflow,P as flip,E as hide,L as inline,B as limitShift,k as offset,C as shift,H as size};export default null;
